-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE MultiWayIf #-}

module Daml.Finance.App.Distribution.Auction.Service where

import DA.Action (foldlA)
import DA.Either (partitionEithers)
import DA.Foldable (forA_)
import DA.List (sortOn, mapAccumL)
import DA.Optional (whenSome)
import DA.Set (fromList, singleton)
import Daml.Finance.Interface.Asset.Account qualified as Account (K, R)
import Daml.Finance.Interface.Asset.Instrument qualified as Instrument (K, Q)
import Daml.Finance.Interface.Asset.Lockable qualified as Lockable (Lock(..), Unlock(..))
import Daml.Finance.Interface.Asset.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Asset.Util (getAccount)
import Daml.Finance.Interface.Common.Disclosure qualified as Disclosure (AddObserver(..))
import Daml.Finance.Interface.Settlement.Instructable qualified as Instructable (I)
import Daml.Finance.Interface.Settlement.Settleable qualified as Settleable (Settle(..))
import Daml.Finance.App.Distribution.Auction.Model (Auction(..), CreateAuctionRequest(..), Status(..))
import Daml.Finance.App.Distribution.Auction.Utils (dutchAuction, splitList, generateSettlementInstruction)
import Daml.Finance.App.Distribution.Bidding.Model qualified as Bidding (Allocation(..), Bid, SettleAllocation(..), Status(..))
import Daml.Finance.App.Distribution.Bidding.Service qualified as Bidding (RejectBid(..), S)
import Daml.Finance.App.Util (fetchAndArchive)

type S = Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice RequestCreateAuction : ContractId CreateAuctionRequest
      with
        id : Text
        quantity : Instrument.Q
        currency : Instrument.K
        floor : Decimal
        collateralCid : ContractId Fungible.I
        receivableAccount : Account.K
      controller customer
      do
        -- Disclose holding
        collateral <- fetch collateralCid
        collateralCid <- coerceContractId <$> exercise collateralCid Disclosure.AddObserver with actor = singleton customer; observerToAdd = (id, fromList [provider])

        -- Disclose delivering securities account
        (_, delRef) <- fetchByKey @Account.R $ getAccount collateral
        exercise delRef.cid Disclosure.AddObserver with actor = singleton customer; observerToAdd = (id, fromList [provider])

        -- Disclose receiving cash account
        (_, recRef) <- fetchByKey @Account.R receivableAccount
        exercise recRef.cid Disclosure.AddObserver with actor = singleton customer; observerToAdd = (id, singleton provider)

        create CreateAuctionRequest with operator; provider; customer; id; quantity; currency; floor; collateralCid; receivableAccount

    nonconsuming choice CancelAuctionRequest : ()
      with
        createAuctionRequestCid : ContractId CreateAuctionRequest
      controller customer
      do
        archive createAuctionRequestCid

    nonconsuming choice CreateAuction : ContractId Auction
      with
        createAuctionRequestCid : ContractId CreateAuctionRequest
      controller provider
      do
        CreateAuctionRequest{id; quantity; currency; floor; collateralCid; receivableAccount} <- fetchAndArchive createAuctionRequestCid
        collateralCid <- coerceContractId <$> exercise collateralCid Lockable.Lock with newLocker = fromList [ provider ]
        create Auction with operator; provider; customer; id; quantity; currency; floor; collateralCid; receivableAccount; status = Open

    nonconsuming choice RejectAuction : ()
      with
        createAuctionRequestCid : ContractId CreateAuctionRequest
      controller provider
      do
        archive createAuctionRequestCid

    nonconsuming choice ProcessAuction : ContractId Auction
      with
        instructableCid : ContractId Instructable.I
        auctionCid : ContractId Auction
        bidCids : [ContractId Bidding.Bid]
      controller provider
      do
        auction@Auction{floor, quantity, collateralCid, status} <- fetch auctionCid
        assertMsg "Auction already successfully processed" (status `elem` [Open, NoValidBids])

        bids <- zip bidCids <$> forA bidCids fetch
        -- Split bids on those above / below the floor price -> Sort valid bids descendingly -> Execute Auction -> Split auction result on allocated / unallocated (ie, zero allocation)
        let
          (invalidBids, validBids) = partitionEithers $ splitList (\(_, bid) -> bid.details.price.amount >= floor) bids
          sortedBids = sortOn (\(_, bid) -> Down bid.details) validBids
          ((remaining, finalPrice), allocations) = mapAccumL dutchAuction (quantity.amount, 0.0) sortedBids
          (allocatedBids, unallocatedBids) = partitionEithers $ splitList (\allocation -> allocation.amount == 0.0) allocations

        -- Return assets of all invalid and unallocated bids. Also update their bid status accordingly
        forA_ invalidBids (\(bidCid, bid) -> exerciseByKey @Bidding.S (bid.operator, bid.provider, bid.customer) Bidding.RejectBid with bidCid; newStatus = Bidding.Invalid)
        forA_ unallocatedBids (\Bidding.Allocation{bidCid, bid} -> exerciseByKey @Bidding.S (bid.operator, bid.provider, bid.customer) Bidding.RejectBid with bidCid; newStatus = Bidding.NoAllocation)

        -- Generate Settlement instructions for allocated bids
        let settleAllocations = (\allocation -> Bidding.SettleAllocation with allocation; price = finalPrice; issuer = customer) <$> allocatedBids
        (remainingDepositCidOpt, settleableCids) <- foldlA (generateSettlementInstruction instructableCid auction.receivableAccount) (Some collateralCid, []) settleAllocations

        -- Settle transfers
        forA_ settleableCids (`exercise` Settleable.Settle)
        -- Return unallocated deposit back to the customer
        whenSome remainingDepositCidOpt \depositCid -> do
          exercise depositCid Lockable.Unlock
          pure ()

        -- Update Auction contract with the outcome of the auction processing
        let newStatus = if
              | remaining == quantity.amount -> NoValidBids
              | remaining > 0.0 -> PartiallyAllocated with finalPrice; remaining
              | otherwise -> FullyAllocated with finalPrice
        archive auctionCid
        create auction with status = newStatus

    choice Terminate : ()
      with
        actor : Party
      controller actor
      do
        assert $ actor == operator || actor == provider || actor == customer
        pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with ..

    choice Decline : ()
      controller customer
      do
        return ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    provider : Party
    customer : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        create Service with ..
