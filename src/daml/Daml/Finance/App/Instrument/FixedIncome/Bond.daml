-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Instrument.FixedIncome.Bond where

import DA.Date (toGregorian)
import Daml.Finance.App.Data.HolidayCalendar (HolidayCalendar)
import Daml.Finance.Interface.Asset.Instrument (Instrument)
import Daml.Finance.Common.Date.Calendar (BusinessDayConventionEnum, BusinessDayAdjustment(..))
import Daml.Finance.Common.Date.RollConvention (PeriodEnum(..), RollConventionEnum(DOM))
import Daml.Finance.Common.Date.Schedule (createSchedule, Frequency(..), PeriodicSchedule(..))
import ContingentClaims.Claim (Claim)
import ContingentClaims.Financial (fixed, floating)
import ContingentClaims.Observation qualified as O

template Factory
  with
    party : Party
  where
    signatory party

    key party : Party
    maintainer key

    choice CreateFixedRate : Claim Date Decimal (ContractId Instrument) Text
      with
        issueDate : Date
        maturityDate : Date
        couponPeriod : PeriodEnum
        couponPeriodMultiplier : Int
        couponPerAnnum : Decimal
        currency : ContractId Instrument
        calendarIds : [Text]
        convention : BusinessDayConventionEnum
      controller party
      do
        calendars <- mapA (\id -> fetchByKey @HolidayCalendar (party, id)) calendarIds
        let
          calendarData = map ((.calendar) . snd) calendars
          (y, m, d) = toGregorian issueDate
          periodicSchedule = PeriodicSchedule with
            effectiveDate = issueDate
            terminationDate = maturityDate
            firstRegularPeriodStartDate = None
            lastRegularPeriodEndDate = None
            frequency = Frequency with period = couponPeriod; periodMultiplier = couponPeriodMultiplier; rollConvention = DOM d
            businessDayAdjustment = BusinessDayAdjustment with calendarIds; convention
            effectiveDateBusinessDayAdjustment = None
            terminationDateBusinessDayAdjustment = None
            stubPeriodType = None
          schedule = createSchedule calendarData periodicSchedule
          dates = map (.adjustedEndDate) schedule
          coupon = case couponPeriod of
            D -> error "Daily coupon period not supported"
            W -> error "Weekly coupon period not supported"
            M -> couponPerAnnum * (intToDecimal couponPeriodMultiplier / 12.0)
            Y -> couponPerAnnum
          claims = fixed 1.0 coupon currency dates
        pure claims

    choice CreateFloatingRate : Claim Date Decimal (ContractId Instrument) Text
      with
        issueDate : Date
        maturityDate : Date
        couponPeriod : PeriodEnum
        couponPeriodMultiplier : Int
        rate : Text
        spread : Decimal
        currency : ContractId Instrument
        calendarIds : [Text]
        convention : BusinessDayConventionEnum
      controller party
      do
        calendars <- mapA (\id -> fetchByKey @HolidayCalendar (party, id)) calendarIds
        let
          calendarData = map ((.calendar) . snd) calendars
          (y, m, d) = toGregorian issueDate
          periodicSchedule = PeriodicSchedule with
            effectiveDate = issueDate
            terminationDate = maturityDate
            firstRegularPeriodStartDate = None
            lastRegularPeriodEndDate = None
            frequency = Frequency with period = couponPeriod; periodMultiplier = couponPeriodMultiplier; rollConvention = DOM d
            businessDayAdjustment = BusinessDayAdjustment with calendarIds; convention
            effectiveDateBusinessDayAdjustment = None
            terminationDateBusinessDayAdjustment = None
            stubPeriodType = None
          schedule = createSchedule calendarData periodicSchedule
          dates = map (.adjustedEndDate) schedule
          coupon = O.observe rate + O.pure spread
          principal = O.pure 1.0
          claims = floating principal coupon currency dates
        pure claims
