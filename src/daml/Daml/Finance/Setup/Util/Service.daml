-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Setup.Util.Service where

import DA.Map qualified as M (fromList)
import DA.Set (fromList, singleton)
import Daml.Finance.App.Custody.Auto qualified as CustodyAuto (Accept(..))
import Daml.Finance.App.Custody.Service qualified as Custody (Accept(..))
import Daml.Finance.App.Decentralized.Exchange.Service qualified as DecentralizedExchange (Service(..))
import Daml.Finance.App.Interface.Custody.Auto qualified as CustodyAuto (I)
import Daml.Finance.App.Interface.Custody.Service qualified as Custody (I)
import Daml.Finance.App.Interface.Decentralized.Exchange.Service qualified as DecentralizedExchange (I)
import Daml.Finance.App.Interface.Decentralized.Exchange.Types (Pool(..))
import Daml.Finance.App.Interface.Distribution.Auction.Auto qualified as AuctionAuto (I)
import Daml.Finance.App.Interface.Distribution.Auction.Service qualified as Auction (I)
import Daml.Finance.App.Interface.Distribution.Bidding.Auto qualified as BiddingAuto (I)
import Daml.Finance.App.Interface.Distribution.Bidding.Service qualified as Bidding (I)
import Daml.Finance.App.Interface.Distribution.Fund.Service qualified as Fund (I)
import Daml.Finance.App.Interface.Distribution.Investment.Service qualified as Investment (I)
import Daml.Finance.App.Interface.Distribution.Subscription.Service qualified as Subscription (I)
import Daml.Finance.App.Interface.Issuance.Auto qualified as IssuanceAuto (I)
import Daml.Finance.App.Interface.Issuance.BackToBack qualified as BackToBack (I)
import Daml.Finance.App.Interface.Issuance.Service qualified as Issuance (I)
import Daml.Finance.App.Interface.Lending.Service qualified as Lending (I)
import Daml.Finance.App.Interface.Lifecycle.Service qualified as Lifecycle (I)
import Daml.Finance.App.Interface.Listing.Auto qualified as ListingAuto (I)
import Daml.Finance.App.Interface.Listing.Service qualified as Listing (I)
import Daml.Finance.App.Interface.Settlement.Service qualified as Settlement (I)
import Daml.Finance.App.Interface.Structuring.Auto qualified as StructuringAuto (I)
import Daml.Finance.App.Interface.Structuring.Service qualified as Structuring (I)
import Daml.Finance.App.Interface.Trading.Auto qualified as TradingAuto (I)
import Daml.Finance.App.Interface.Trading.Service qualified as Trading (I)
import Daml.Finance.App.Issuance.Auto qualified as IssuanceAuto (Accept(..))
import Daml.Finance.App.Issuance.BackToBack qualified as BackToBack (Accept(..))
import Daml.Finance.App.Issuance.Service qualified as Issuance (Accept(..))
import Daml.Finance.App.Listing.Auto qualified as ListingAuto (Accept(..))
import Daml.Finance.App.Listing.Service qualified as Listing (Accept(..))
import Daml.Finance.App.Lifecycle.Service qualified as Lifecycle (Accept(..))
import Daml.Finance.App.Trading.Auto qualified as TradingAuto (Accept(..))
import Daml.Finance.App.Trading.Service qualified as Trading (Accept(..))
import Daml.Finance.App.Lending.Service qualified as Lending (Accept(..))
import Daml.Finance.App.Distribution.Auction.Auto qualified as AuctionAuto (Accept(..))
import Daml.Finance.App.Distribution.Auction.Service qualified as Auction (Accept(..))
import Daml.Finance.App.Distribution.Bidding.Auto qualified as BiddingAuto (Accept(..))
import Daml.Finance.App.Distribution.Bidding.Service qualified as Bidding (Accept(..))
import Daml.Finance.App.Distribution.Fund.Service qualified as Fund (Accept(..))
import Daml.Finance.App.Distribution.Investment.Service qualified as Investment (Accept(..))
import Daml.Finance.App.Distribution.Subscription.Service qualified as Subscription (Accept(..))
import Daml.Finance.App.Role.Custodian qualified as Custodian
import Daml.Finance.App.Role.Distributor qualified as Distributor
import Daml.Finance.App.Role.Exchange qualified as Exchange
import Daml.Finance.App.Settlement.Service qualified as Settlement (Accept(..))
import Daml.Finance.App.Structuring.Auto qualified as StructuringAuto (Accept(..))
import Daml.Finance.App.Structuring.Service qualified as Structuring (Accept(..))
import Daml.Finance.Instrument.Bond.FixedRate.Factory qualified as FixedRateBond (Factory(..))
import Daml.Finance.Instrument.Bond.FloatingRate.Factory qualified as FloatingRateBond (Factory(..))
import Daml.Finance.Instrument.Bond.InflationLinked.Factory qualified as InflationLinkedBond (Factory(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon.Factory qualified as ZeroCouponBond (Factory(..))
import Daml.Finance.Instrument.Equity.Factory qualified as Equity (Factory(..))
import Daml.Finance.Instrument.Generic.Factory qualified as Generic (Factory(..))
import Daml.Finance.Instrument.Swap.Fpml.Factory qualified as FpmlSwap (Factory(..))
import Daml.Finance.Instrument.Token.Factory qualified as Token (Factory(..))
import Daml.Finance.Interface.Account.Factory qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Settlement.Factory qualified as SettlementFactory (I)
import Daml.Finance.Interface.Settlement.RouteProvider qualified as RouteProvider (I)
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentQuantity)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, AddObservers(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.Lifecycle.Rule.Distribution qualified as Distribution (Rule(..))
import Daml.Finance.Lifecycle.Rule.Replacement qualified as Replacement (Rule(..))
import Daml.Script

createCustodyService : Party -> Party -> Party -> ContractId Account.F -> ContractId Holding.F -> Script (ContractId Custody.I)
createCustodyService operator custodian customer accountFactoryCid holdingFactoryCid = do
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferCustodyService with customer; accountFactoryCid; holdingFactoryCid
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Custody.Accept

createCustodyAutoService : Party -> Party -> Party -> ContractId Account.F -> ContractId Holding.F -> Script (ContractId CustodyAuto.I)
createCustodyAutoService operator custodian customer accountFactoryCid holdingFactoryCid = do
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferCustodyAutoService with customer; accountFactoryCid; holdingFactoryCid
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid CustodyAuto.Accept

createIssuanceService : Party -> Party -> Party -> Script (ContractId Issuance.I)
createIssuanceService operator custodian customer = do
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferIssuanceService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Issuance.Accept

createIssuanceAutoService : Party -> Party -> Party -> Script (ContractId IssuanceAuto.I)
createIssuanceAutoService operator custodian customer = do
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferIssuanceAutoService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid IssuanceAuto.Accept

createStructuringService : Party -> Party -> Party -> Script (ContractId Structuring.I)
createStructuringService operator custodian customer = do
  token <- toInterfaceContractId <$> submit custodian do createCmd Token.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  equity <- toInterfaceContractId <$> submit custodian do createCmd Equity.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  generic <- toInterfaceContractId <$> submit custodian do createCmd Generic.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  fixedRateBond <- toInterfaceContractId <$> submit custodian do createCmd FixedRateBond.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  floatingRateBond <- toInterfaceContractId <$> submit custodian do createCmd FloatingRateBond.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  inflationLinkedBond <- toInterfaceContractId <$> submit custodian do createCmd InflationLinkedBond.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  zeroCouponBond <- toInterfaceContractId <$> submit custodian do createCmd ZeroCouponBond.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  fpmlSwap <- toInterfaceContractId <$> submit custodian do createCmd FpmlSwap.Factory with provider = custodian; observers = M.fromList [("Default", singleton customer)]
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferStructuringService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Structuring.Accept

createStructuringAutoService : Party -> Party -> Party -> Script (ContractId StructuringAuto.I)
createStructuringAutoService operator custodian customer = do
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferStructuringAutoService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid StructuringAuto.Accept

createBackToBackIssuanceService : Party -> Party -> Party -> Party -> Script (ContractId BackToBack.I)
createBackToBackIssuanceService operator custodian customer public = do
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferBackToBackService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid BackToBack.Accept

createLifecycleService : Party -> Party -> Party -> Party -> Script (ContractId Lifecycle.I)
createLifecycleService operator custodian customer public = do
  distributionRuleCid <- toInterfaceContractId <$> submit custodian do createCmd Distribution.Rule with providers = singleton custodian; id = Id "DR"; description = ""; lifecycler = customer; observers = singleton public
  replacementRuleCid <- toInterfaceContractId <$> submit custodian do createCmd Replacement.Rule with providers = singleton custodian; id = Id "DR"; description = ""; lifecycler = customer; observers = singleton public
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferLifecycleService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Lifecycle.Accept

createTradingService : Party -> Party -> Party -> Script (ContractId Trading.I)
createTradingService operator exchange customer = do
  offerCid <- submit exchange do exerciseByKeyCmd @Exchange.Role (operator, exchange) Exchange.OfferTradingService with customer
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Trading.Accept

createTradingAutoService : Party -> Party -> Party -> Script (ContractId TradingAuto.I)
createTradingAutoService operator exchange customer = do
  offerCid <- submit exchange do exerciseByKeyCmd @Exchange.Role (operator, exchange) Exchange.OfferTradingAutoService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid TradingAuto.Accept

createListingService : Party -> Party -> Party -> Script (ContractId Listing.I)
createListingService operator exchange customer = do
  offerCid <- submit exchange do exerciseByKeyCmd @Exchange.Role (operator, exchange) Exchange.OfferListingService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Listing.Accept

createListingAutoService : Party -> Party -> Party -> Script (ContractId ListingAuto.I)
createListingAutoService operator exchange customer = do
  offerCid <- submit exchange do exerciseByKeyCmd @Exchange.Role (operator, exchange) Exchange.OfferListingAutoService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid ListingAuto.Accept

createAuctionService : Party -> Party -> Party -> Script (ContractId Auction.I)
createAuctionService operator distributor customer = do
  offerCid <- submit distributor do exerciseByKeyCmd @Distributor.Role (operator, distributor) Distributor.OfferAuctionService with customer
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Auction.Accept

createAuctionAutoService : Party -> Party -> Party -> Script (ContractId AuctionAuto.I)
createAuctionAutoService operator distributor customer = do
  offerCid <- submit distributor do exerciseByKeyCmd @Distributor.Role (operator, distributor) Distributor.OfferAuctionAutoService with customer
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid AuctionAuto.Accept

createBiddingService : Party -> Party -> Party -> Script (ContractId Bidding.I)
createBiddingService operator distributor customer = do
  offerCid <- submit distributor do exerciseByKeyCmd @Distributor.Role (operator, distributor) Distributor.OfferBiddingService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Bidding.Accept

createBiddingAutoService : Party -> Party -> Party -> Script (ContractId BiddingAuto.I)
createBiddingAutoService operator distributor customer = do
  offerCid <- submit distributor do exerciseByKeyCmd @Distributor.Role (operator, distributor) Distributor.OfferBiddingAutoService with ..
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid BiddingAuto.Accept

createSubscriptionService : Party -> Party -> Party -> Party -> Script (ContractId Subscription.I)
createSubscriptionService operator distributor customer public = do
  offerCid <- submit distributor do exerciseByKeyCmd @Distributor.Role (operator, distributor) Distributor.OfferSubscriptionService with customer; public
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Subscription.Accept

createLendingService : Party -> Party -> Party -> Script (ContractId Lending.I)
createLendingService operator lender borrower = do
  offerCid <- submit lender do exerciseByKeyCmd @Custodian.Role (operator, lender) Custodian.OfferLendingService with customer = borrower
  toInterfaceContractId <$> submit borrower do exerciseCmd offerCid Lending.Accept

createSettlementService : Party -> Party -> Party -> ContractId RouteProvider.I -> ContractId SettlementFactory.I -> Script (ContractId Settlement.I)
createSettlementService operator custodian customer routerCid factoryCid = do
  -- TODO: Seems wrong to have the claim rule on the settlement service. Parties then need the service just for claiming.
  let providers = fromList [custodian, customer]
  claimRuleCid <- toInterfaceContractId <$> submitMulti [custodian, customer] [] do createCmd Claim.Rule with providers; claimers = providers; settlers = providers; routeProviderCid = routerCid; settlementFactoryCid = factoryCid; netInstructions = False
  offerCid <- submit custodian do exerciseByKeyCmd @Custodian.Role (operator, custodian) Custodian.OfferSettlementService with customer; routerCid; factoryCid; claimRuleCid
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Settlement.Accept

createInvestmentService : Party -> Party -> Party -> Script (ContractId Investment.I)
createInvestmentService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Distributor.Role (operator, provider) Distributor.OfferInvestmentService with customer
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Investment.Accept

createFundService : Party -> Party -> Party -> Script (ContractId Fund.I)
createFundService operator provider customer = do
  offerCid <- submit provider do exerciseByKeyCmd @Distributor.Role (operator, provider) Distributor.OfferFundService with customer
  toInterfaceContractId <$> submit customer do exerciseCmd offerCid Fund.Accept

createDecentralizedExchangeService : Party -> Party -> Text -> InstrumentQuantity -> InstrumentQuantity -> AccountKey -> ContractId Fungible.I -> InstrumentQuantity -> AccountKey -> ContractId Fungible.I -> Script (ContractId DecentralizedExchange.I)
createDecentralizedExchangeService consortium public id shares quantity1 account1 fungible1Cid quantity2 account2 fungible2Cid = do
  fungible1Cid <- coerceContractId <$> submit consortium do exerciseCmd (toInterfaceContractId @Disclosure.I fungible1Cid) Disclosure.AddObservers with disclosers = singleton consortium; observersToAdd = (id, singleton public)
  fungible2Cid <- coerceContractId <$> submit consortium do exerciseCmd (toInterfaceContractId @Disclosure.I fungible2Cid) Disclosure.AddObservers with disclosers = singleton consortium; observersToAdd = (id, singleton public)
  let
    p1 = Pool with quantity = quantity1; account = account1; fungibleCid = fungible1Cid
    p2 = Pool with quantity = quantity2; account = account2; fungibleCid = fungible2Cid
  toInterfaceContractId <$> submit consortium do createCmd DecentralizedExchange.Service with consortium; public; id = Id id; description = id; shares; p1; p2
