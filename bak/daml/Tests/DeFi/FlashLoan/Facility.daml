-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Tests.DeFi.FlashLoan.Facility where

import DA.Set (fromList, singleton)
import Daml.Finance.Interface.Asset.Holding (Issue(..))
import Daml.Finance.Interface.Asset.Transferable (Transferable, Transfer(..))
import Daml.Script
import DeFi.FlashLoan.Facility (Facility(..), FlashLoan(..))
import DeFi.FlashSwap.Dvp (Dvp, Deliver(..), Pay(..), Settle(..))
import DeFi.Interface.FlashSwapAction (FlashSwapAction)
import Tests.Setup

-- settle trade once both counterparties have committed
-- alice *<-> ccp <->* bob
template SettleTrade with
    ccp : Party
    custodian : Party
    public : Party
    dvp1LeftAllocatedCid : ContractId Dvp
    dvp2RightAllocatedCid : ContractId Dvp
  where
    -- FIXME: Having public as a signatory is required due to the signatory check on FlashSwapAction.Execute
    -- We have to pass in [ccp, public] as choiceControllers there so that instruments can be fetched
    signatory ccp, custodian, public

    implements FlashSwapAction where
      let action = \paymentCid -> do
          (dvp1Cid, rest1Cids) <- exercise dvp1LeftAllocatedCid Pay with actors = fromList [ccp, custodian, public]; tokenCid = paymentCid
          (payed1Cid, delivered1Cid) <- exercise dvp1Cid Settle with actors = fromList [ccp, custodian]
          (dvp2Cid, rest2Cids) <- exercise dvp2RightAllocatedCid Deliver with actors = fromList [ccp, custodian, public]; tokenCid = delivered1Cid
          (payed2Cid, delivered2Cid) <- exercise dvp2Cid Settle with actors = fromList [ccp, custodian]
          return (payed2Cid, [payed1Cid, delivered2Cid] <> rest1Cids <> rest2Cids)

{-       FlashLoanFacility
                *
                ^
                |
                v
    alice *<-> ccp <->* bob

    ccp can settle a trade between alice and bob using a FlashLoan facility
    (i.e., without any assets upfront)
-}
testFlashLoan : Script ()
testFlashLoan = do
  -- Setup
  LedgerParties{..} <- setupParties
  LedgerTokens{..} <- setupTokens LedgerParties{..}

  -- Distribute assets
  aliceEthCid <- submit custodian1 do exerciseCmd ethInstrumentCid Issue with quantity = 10.0
  let aliceEthTransferable : ContractId Transferable = coerceContractId aliceEthCid
  aliceEthCid <- submitMulti [custodian1, alice] [] do exerciseCmd aliceEthTransferable Transfer with newOwners = singleton alice
  bobUsdcCid <- submit custodian2 do exerciseCmd usdcInstrumentCid Issue with quantity = 42_390.0
  let bobUsdcTransferable : ContractId Transferable = coerceContractId bobUsdcCid
  bobUsdcCid <- submitMulti [custodian2, bob] [] do exerciseCmd bobUsdcTransferable Transfer with newOwners = singleton bob

  dvp1Cid <- createDvp alice (10.0, ethInstrumentCid) ccp (42_390.0, usdcInstrumentCid) (fromList [ccp, custodian2]) public
  dvp2Cid <- createDvp ccp (10.0, ethInstrumentCid) bob (42_390.0, usdcInstrumentCid) (fromList [ccp, custodian2]) public

  -- Allocation of alice and bob
  -- alice *<-> ccp <->* bob
  (dvp1Cid, _) <- submitMulti [alice, public] [] do exerciseCmd dvp1Cid Deliver with actors = fromList [alice, public], tokenCid = aliceEthCid
  (dvp2Cid, _) <- submitMulti [bob, public] [] do exerciseCmd dvp2Cid Pay with actors = fromList [bob, public], tokenCid = bobUsdcCid

  -- Prepare settlement (as FlashSwapAction)
  settleTradeCid <- submitMulti [ccp, custodian2, public] [] do createCmd SettleTrade with ccp; custodian = custodian2; public; dvp1LeftAllocatedCid = dvp1Cid; dvp2RightAllocatedCid = dvp2Cid
  let flashSwapActionCid = toInterfaceContractId @FlashSwapAction settleTradeCid

  facilityCid <- submit custodian2 do createCmd Facility with provider = singleton custodian2; instrumentCid = usdcInstrumentCid; public
  submitMulti [ccp, public] [] do exerciseCmd facilityCid FlashLoan with actors = fromList [ccp, public]; quantity = 42_390.0; actionCid = flashSwapActionCid

  return ()