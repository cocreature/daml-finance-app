-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module DeFi.FlashSwap.Dex where

import DA.Assert ((===))
import DA.Numeric
import DA.Set (Set, delete, empty)
import DeFi.Interface.FlashSwapAction
import Daml.Finance.Interface.Common.Disclosure (Disclosable, Disclose(..))
import Daml.Finance.Interface.Asset.Fungible (Fungible, Split(..), Merge(..))
import Daml.Finance.Interface.Asset.Holding (Instrument, Issue(..), getQuantity, getTypeRep)
import Daml.Finance.Interface.Asset.Transferable (Transferable, Transfer(..), getInstrument)
import Daml.Finance.Interface.Common.Types (Parties)

-- Liquidty pool
data Pool = Pool with
    tokenCid : ContractId Transferable
    instrumentCid : ContractId Instrument
  deriving (Eq, Show)

-- See README.md
template Dex
  with
    id : Text
    consortium : Parties
    share : (Decimal, ContractId Instrument)
    pool1 : Pool
    pool2 : Pool
    fee : Decimal
    public : Party
  where
    signatory consortium
    observer public

    -- TODO: Replace with assertions in choices
    -- ensure
    --   pool1.token.asset.quantity > 0.0 && pool2.token.asset.quantity > 0.0 &&
    --   share._1.asset.quantity > 0.0 && fee > 0.0 &&
    --   pool1.token.account.owners == pool2.token.account.owners &&
    --   share._1.account.owners == pool2.token.account.owners

    -- AMM rule
    let
      constantProductFormula (delta_x : Decimal) (x : Decimal) (y : Decimal) =
        do
          let
            k = x * y
            x_new = x + delta_x
            -- deducting fee from input
            x_new_used = x + delta_x * (1.0 - fee)
            y_new = div k x_new_used
            delta_y = y - y_new
            marketPrice : Decimal = div y x
            tradePrice : Decimal = div delta_y delta_x
            slippagePercent : Numeric 4 = div
              (abs(marketPrice - tradePrice))
              marketPrice * 100.0
          assertMsg "positive deltas" $ delta_x > 0.0 && delta_y > 0.0
          debug $ "slippage: " <> show (slippagePercent) <> "%"
          return (x_new, y_new, delta_y)

      -- Flash swap
      flashSwapBy (actors : Parties) (xAsset : (Decimal, ContractId Instrument)) (xPool : Pool) (yPool : Pool) (flashSwapActionCid : ContractId FlashSwapAction) =
        do
          let newOwners = delete public actors

          -- Quantities to exchange
          xPoolToken <- fetch xPool.tokenCid
          yPoolToken <- fetch yPool.tokenCid
          (x_new, y_new, delta_y) <- constantProductFormula (fst xAsset) (getQuantity xPoolToken) (getQuantity yPoolToken)

          -- Split off Y token
          (yTokenCid, yPoolCid_new) <- do
            let yPoolFungibleCid : ContractId Fungible = coerceContractId yPool.tokenCid
            result <- exercise yPoolFungibleCid Split with quantities = [delta_y] -- (disallow draining)
            let [yFungibleCid, yRestCid] = result
            let yPoolTransferableCid : ContractId Transferable = coerceContractId yFungibleCid
            yPoolTransferableCid <- exercise yPoolTransferableCid Disclose with newObservers = newOwners
            let
              yTransferableCid : ContractId Transferable = coerceContractId yPoolTransferableCid
              yRestTransferableCid : ContractId Transferable = coerceContractId yRestCid
            return (yTransferableCid, yRestTransferableCid)

          -- Transfer Y to actor
          yTokenCid_new <- exercise yTokenCid Transfer with newOwners

          -- Execute flashSwapAction and get X
          (xTokenCid, restCids) <-
            exercise flashSwapActionCid Execute with
              choiceControllers = actors
              tokenIn = (delta_y, yPool.instrumentCid)
              tokenInCid = yTokenCid_new
              tokenOut = xAsset

          -- Transfer X to dex
          xPoolCid_new <- do
            xTokenCid_new <- exercise xTokenCid Transfer with newOwners = consortium
            let
              xFungibleCid_new : ContractId Fungible = coerceContractId xTokenCid_new
              xPoolFungibleCid : ContractId Fungible = coerceContractId xPool.tokenCid
            xPoolCid_new <- exercise xPoolFungibleCid Merge with fungibleCids = [xFungibleCid_new]
            let xTransferableCid_new : ContractId Transferable = coerceContractId xPoolCid_new
            pure xTransferableCid_new

          -- update pools
          let
            xPool_new = xPool with tokenCid = xPoolCid_new
            yPool_new = yPool with tokenCid = yPoolCid_new

          pure (xPool_new, yPool_new, restCids)

    postconsuming choice Deposit : (ContractId Dex, ContractId Transferable, [ContractId Transferable])
      with
        actors : Parties
        token1Cid : ContractId Transferable
        token2Cid : ContractId Transferable
      controller actors
      do
        let newOwners = delete public actors

        -- Check token1
        pool1Token <- fetch pool1.tokenCid
        let pool1Instrument = getInstrument pool1Token
        token1 <- fetch token1Cid
        let instrument1Cid = getInstrument token1
        instrument1 <- fetch instrument1Cid
        assertMsg "Token 1 has wrong instrument" $ instrument1Cid == pool1Instrument
        assertMsg "Token 1 has wrong type" $ getTypeRep instrument1 == interfaceTypeRep pool1Token

        -- Check token2
        pool2Token <- fetch pool2.tokenCid
        let pool2Instrument = getInstrument pool2Token
        token2 <- fetch token2Cid
        let instrument2Cid = getInstrument token2
        instrument2 <- fetch instrument2Cid
        assertMsg "Token 2 has wrong instrument" $ instrument2Cid == pool2Instrument
        assertMsg "Token 2 has wrong type" $ getTypeRep instrument2 == interfaceTypeRep pool2Token

        -- Determine if pool should be switched
        let flipped = getQuantity token1 <= div (getQuantity token2 * getQuantity pool1Token) (getQuantity pool2Token)

        -- Switch to X and Y
        let
          ((xTokenCid, xToken, xPool, xPoolToken), (yTokenCid, yToken, yPool, yPoolToken)) =
            if flipped
            then ((token2Cid, token2, pool2, pool2Token), (token1Cid, token1, pool1, pool1Token))
            else ((token1Cid, token1, pool1, pool1Token), (token2Cid, token2, pool2, pool2Token))

        -- Split off right quantity of X tokens
        let
          xQuantity : Decimal = div (getQuantity yToken * getQuantity xPoolToken) (getQuantity yPoolToken)
          xTokenFungibleCid : ContractId Fungible = coerceContractId xTokenCid
        (xTokenSplitCid :: xTokenRestCids) : [ContractId Transferable] <- map coerceContractId <$> exercise xTokenFungibleCid Split with quantities = [xQuantity]

        -- Add liquidity to pools
        xPoolTokenCid_new <- do
          cid <- exercise xTokenSplitCid Transfer with newOwners = consortium
          let xPoolFungibleCid : ContractId Fungible = coerceContractId xPool.tokenCid
          exercise xPoolFungibleCid Merge with fungibleCids = [coerceContractId cid]
        xPoolToken_new <- fetch xPoolTokenCid_new
        yPoolTokenCid_new <- do
          cid <- exercise yTokenCid Transfer with newOwners = consortium
          let yPoolFungibleCid : ContractId Fungible = coerceContractId yPool.tokenCid
          exercise yPoolFungibleCid Merge with fungibleCids = [coerceContractId cid]
        yPoolToken_new <- fetch yPoolTokenCid_new
        let
          xPool_new = xPool with tokenCid = coerceContractId xPoolTokenCid_new
          yPool_new = yPool with tokenCid = coerceContractId yPoolTokenCid_new

        -- Spawn participation tokens
        let
          nrSharesIssued = div (share._1 * getQuantity xPoolToken_new) (getQuantity xPoolToken) - share._1
          nrSharesTotal = share._1 + nrSharesIssued
        shareCid <- exercise share._2 Issue with quantity = nrSharesIssued
        let shareTransferableCid : ContractId Transferable = coerceContractId shareCid
        shareCid <- exercise shareTransferableCid Transfer with newOwners

        -- Switch back to pool 1 and 2
        let
          (pool1_new, pool2_new) =
            if flipped
            then (yPool_new, xPool_new)
            else (xPool_new, yPool_new)

        -- Recreate Dex
        dexCid <- create this with
          share = (nrSharesTotal, share._2)
          pool1 = pool1_new
          pool2 = pool2_new
        return (dexCid, shareCid, xTokenRestCids)

    postconsuming choice Withdraw : (ContractId Dex, ContractId Transferable, ContractId Transferable)
      with
        actors : Set Party
        shareCid : ContractId Transferable
      controller actors
      do
        let newOwners = delete public actors

        -- Check share
        s <- fetch shareCid
        let instrumentCid = getInstrument s
        instrument <- fetch instrumentCid
        instrumentCid === share._2
        assertMsg "Share has wrong type" $ getTypeRep instrument == interfaceTypeRep s

        -- Transfer share to consortium and archive
        cid <- exercise shareCid Transfer with newOwners = consortium
        -- TODO: Archive not possible on interface
        -- exercise cid Archive

        -- Compute share of liquidity pool
        pool1Token <- fetch pool1.tokenCid
        pool2Token <- fetch pool2.tokenCid
        let
          pool1Quantity = getQuantity pool1Token
          pool2Quantity = getQuantity pool2Token
          nShares = getQuantity s
          nToken1 = div (nShares * pool1Quantity) share._1
          nToken2 = div (nShares * pool2Quantity) share._1

        -- Split and transfer token 1 (not allowing to drain)
        let pool1FungibleCid : ContractId Fungible = coerceContractId pool1.tokenCid
        [split1Cid, rest1Cid] <- exercise pool1FungibleCid Split with quantities = [nToken1]
        let disclosableCid : ContractId Disclosable = coerceContractId split1Cid
        split1Cid <- exercise disclosableCid Disclose with newObservers = empty
        let transferableCid : ContractId Transferable = coerceContractId split1Cid
        t1Cid <- exercise transferableCid Transfer with newOwners

        -- Split and transfer token 2 (not allowing to drain)
        let pool2FungibleCid : ContractId Fungible = coerceContractId pool2.tokenCid
        [split2Cid, rest2Cid] <- exercise pool2FungibleCid Split with quantities = [nToken2]
        let disclosableCid : ContractId Disclosable = coerceContractId split2Cid
        split2Cid <- exercise disclosableCid Disclose with newObservers = empty
        let transferableCid : ContractId Transferable = coerceContractId split2Cid
        t2Cid <- exercise transferableCid Transfer with newOwners

        -- Recreate dex with new state
        dexCid <- create this with
          share = (share._1 - nShares, share._2)
          pool1 = pool1 with tokenCid = coerceContractId rest1Cid
          pool2 = pool2 with tokenCid = coerceContractId rest2Cid
        return (dexCid, t1Cid, t2Cid)

    -- FIXME: Can't make the choice consuming
    postconsuming choice FlashSwap : (ContractId Dex, [ContractId Transferable])
      with
        actors : Set Party
        xAsset : (Decimal, ContractId Instrument)
        actionCid : ContractId FlashSwapAction
      controller actors
      do
        -- Assert asset is either from pool 1 or 2
        assertMsg "Asset must match pool 1 or 2" $ snd xAsset == pool1.instrumentCid || snd xAsset == pool2.instrumentCid

        -- Flip to X an Y
        let
          (xPool, yPool) =
            if snd xAsset == pool1.instrumentCid
            then (pool1, pool2)
            else (pool2, pool1)

        -- Flash swap
        (xPool_new, yPool_new, restCids) <- flashSwapBy actors xAsset xPool yPool actionCid

        -- Flip back to pool1 and pool2
        let
          (pool1_new, pool2_new) =
            if snd xAsset == pool1.instrumentCid
            then (xPool_new, yPool_new)
            else (yPool_new, xPool_new)

        -- Recreate dex
        dexCid <- create this with pool1 = pool1_new, pool2 = pool2_new
        return (dexCid, restCids)

    -- FIXME: Need to make this nonconsuming, as FlashSwap consumes the current contract already (otherwise, we get an "already consumed" error)
    nonconsuming choice Swap : (ContractId Dex, [ContractId Transferable])
      with
        actors : Set Party
        xTokenCid : ContractId Transferable
      controller actors
      do
        -- Swap with help of FlashSwap and FlashSwapActionPure
        xToken <- fetch xTokenCid
        let
          xQuantity = getQuantity xToken
          xInstrument = getInstrument xToken
        pipeCid <- toInterfaceContractId <$> create FlashSwapActionPure with actors, outCid = xTokenCid
        exercise self FlashSwap with actors; xAsset = (xQuantity, xInstrument); actionCid = pipeCid

-- Example of a FlashSwapAction template (used for a normal DEX Swap)
template FlashSwapActionPure with
    actors : Set Party
    outCid : ContractId Transferable
  where
    signatory actors

    implements FlashSwapAction where
      let action = \inCid -> return (outCid, [inCid])