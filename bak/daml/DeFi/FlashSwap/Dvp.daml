-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module DeFi.FlashSwap.Dvp where

import DA.Assert ((===))
import DA.Optional
import DA.Set (Set, delete, union)
import Daml.Finance.Interface.Common.Types (Parties)
import Daml.Finance.Interface.Common.Disclosure (Disclose(..))
import Daml.Finance.Interface.Asset.Fungible (Fungible, Split(..))
import Daml.Finance.Interface.Asset.Holding (Instrument, getQuantity, getTypeRep)
import Daml.Finance.Interface.Asset.Transferable (Transferable, Transfer(..), getInstrument, getOwners)
import DeFi.Interface.FlashSwapAction

data Allocation = Allocation with
    tokenCid : Optional (ContractId Transferable)
    required : (Decimal, ContractId Instrument)
    beneficiary : Parties
  deriving (Eq, Show)

-- Dvp for testing FlashSwap feature
template Dvp with
    delivery : Allocation
    payment : Allocation
    settlementParticipant : Parties
    public : Party
  where
    signatory delivery.beneficiary, payment.beneficiary
    observer settlementParticipant

    let
      allocate (allocation : Allocation) (tokenCid : ContractId Transferable) = do
        -- Check token
        requiredInstrument <- fetch $ snd allocation.required
        token <- fetch tokenCid
        let instrumentCid = getInstrument token
        instrument <- fetch instrumentCid
        instrumentCid === snd allocation.required
        assertMsg "Token has wrong type" $ getTypeRep requiredInstrument == interfaceTypeRep token

        let otherA = if (allocation == delivery) then payment else delivery
        cid <- exercise tokenCid Disclose with newObservers = union otherA.beneficiary settlementParticipant
        let fungibleCid : ContractId Fungible = coerceContractId cid
        splitCid :: restCids <- exercise fungibleCid Split with quantities = [fst allocation.required]
        let newAllocation = allocation with tokenCid = Some $ coerceContractId splitCid
        dvpCid <-
          if (allocation == delivery)
          then create this with delivery = newAllocation
          else create this with payment = newAllocation
        return (dvpCid, map coerceContractId restCids)

      flashSwap (choiceControllers : Set Party)
                (xAllocation : Allocation)
                (yAllocation : Allocation)
                (actionCid : ContractId FlashSwapAction) =
        do
          -- Get Y from counterparty
          let yTokenCid = fromSome yAllocation.tokenCid
          yToken <- fetch yTokenCid
          let
            yQuantity = getQuantity yToken
            yInstrument = getInstrument yToken
          yTokenCid <- exercise yTokenCid Transfer with newOwners = yAllocation.beneficiary
          yTokenCid <- exercise yTokenCid Disclose with newObservers = settlementParticipant

          -- Flash action
          (xTokenCid, restCids) <- exercise actionCid Execute with
            choiceControllers
            tokenIn = yAllocation.required
            tokenInCid = coerceContractId yTokenCid
            tokenOut = xAllocation.required

          -- Deliver X to counterparty
          xTokenCid <- exercise xTokenCid Transfer with newOwners = xAllocation.beneficiary
          xTokenCid <- exercise xTokenCid Disclose with newObservers = settlementParticipant

          return (coerceContractId xTokenCid, restCids)

    postconsuming choice Deliver : (ContractId Dvp, [ContractId Transferable])
      with
        actors : Set Party
        tokenCid : ContractId Transferable
      controller actors
      do
        token <- fetch tokenCid
        let owners = getOwners token
        assertMsg "Actors match must be owners or settlement participant" $ delete public actors == owners || delete public actors == settlementParticipant
        allocate delivery tokenCid

    postconsuming choice Pay : (ContractId Dvp, [ContractId Transferable])
      with
        actors : Set Party
        tokenCid : ContractId Transferable
      controller actors
      do
        token <- fetch tokenCid
        let owners = getOwners token
        assertMsg "Actors match must be owners or settlement participant" $ delete public actors == owners || delete public actors == settlementParticipant
        allocate payment tokenCid

    postconsuming choice FlashPayAndSettle : (ContractId Transferable, [ContractId Transferable])
      with
        actors : Set Party
        actionCid : ContractId FlashSwapAction
      controller actors
      do
        flashSwap actors payment delivery actionCid

    postconsuming choice FlashDeliverAndSettle : (ContractId Transferable, [ContractId Transferable])
      with
        actors : Set Party
        actionCid : ContractId FlashSwapAction
      controller actors
      do
        flashSwap actors delivery payment actionCid

    postconsuming choice Settle : (ContractId Transferable, ContractId Transferable)
      with
        actors : Set Party
      controller actors
      do
        let
          deliveryCid = fromSome delivery.tokenCid
          paymentCid = fromSome payment.tokenCid
        deliveredCid <- exercise deliveryCid Transfer with newOwners = delivery.beneficiary
        delivered <- fetch deliveredCid
        let deliveredOwners = getOwners delivered
        deliveredCid <- coerceContractId <$> exercise deliveredCid Disclose with newObservers = union deliveredOwners settlementParticipant
        payedCid <- exercise paymentCid Transfer with newOwners = payment.beneficiary
        payed <- fetch payedCid
        let payedOwners = getOwners payed
        payedCid <- coerceContractId <$> exercise payedCid Disclose with newObservers = union payedOwners settlementParticipant
        return (payedCid, deliveredCid)
